복습 -> 팝업창과 모달창 -> defer, async -> java 쓰레드 -> javascript 쓰레드 -> 동기와 비동기 

0. 복습 
1) DOM 트리 
	웹 문서의 구조와 정보들을 트리 형태로 저장한다 
	DOM 트리를 구성하는 하나하나 요소를 노드라고 하고 
	최상위노드를 root 노드(document 노드) 
	각 노드들은 위치에 따라 부모, 자식, 형제, 조상노드라고 한다 
	태그노드, 속성노드, 텍스트노드 등이 있다 
	
2) DOM(Document Object Model) 
	html 태그들을 하나씩 객체화 한 것을 의미한다 

3) DOM Selector 종류 
- HTMLCollection 반환하는 메소드 : 실시간(live) 컬렉션 


- NodeList 반환하는 메소드 : 정적(static)리스트(단, Node.childNodes는 예외적으로 live일 수 있음) 
	document.getElementById("id")			단일 요소 반환(HTML 요소 1개)
	document.getElementsByClassName("class명")	같은 클래스명을 가진 요소들 반환(HTMLCollection)
	document.getElementByTagName("tag명")		태그이름으로 요소들 반환(HTMLCollction)

- NodeList 반환하는 메소드 : 정적(static)리스트(단, Node.childNodes는 예외적으로 live일 수 있음) 
	document.getElementsByName('name명') 		name 속성으로 요소들 선택(NodeList) 
	document.querySelector('css선택자')		첫번째 일치하는 요소만 반환(element) 
	document.querySelectorAll('css선택자')		모든 일치하는 요소들 반환(NodeList) 

		HTMLCollection		NodeList
반복가능		for, for ... of 	for, for ... of, forEach 
실시간		실시간반영 		실시간반영되지않음 

		HTMLCollection.prototype.forEach = Array.prototype.forEach 

4) 요소 내용 가져오기, 수정하기 
- 요소.innerHTML
- 요소.innerText 

5) 요소 속성 가져오기, 수정하기, 삭제하기 
- 요소.getAttribute('속성명') 
- 요소.setAttribute('속성명', '값') 
- 요소.removeAttribute('속성명) 

6) DOM을 활용한 이벤트처리 
- DOM 요소에 이벤트 핸들러 직접 연결시키기 
	요소.on이벤트명 = 함수; 

- addEventListenenr()메소드 사용하기 
	요소.addEventListener(이벤트, 함수); 

--------------------------------------------------------------------------------------
1. 팝업창과 모달창 
1) 팝업창 
	현재 페이지에 새로운 브라우저 창을 열어주는 것 
	브라우저 설정에 따라 팝업창을 막아두는 경우가 있다 
	최근엔 사용 빈도가 급격히 떨어졌다 

2) 모델창
	라이트박스를 하나의 팝업창처럼 사용한다 
	팝업창과 비교했을 때 실제 브라우저 창이 아니라 새로운 레이어를 띄워준다는 차이가 있다 

2. defer, async
	웹 브라우저에서 돌아가는 스크립트는 대부분 HTML보다 무겁다 
	용량이 커서 다운로드 받을 때도 오랜 시간이 걸리고 처리할 때도 오래 걸린다 

	브라우저는 HTML을 읽다가 <script></script> 태그를 만나면 스크립트를 먼저 실행해야하므로 DOM생성을 멈춘다
	src 속성이 있는 외부 스크립트가 적용되어도 동일하다 
	
	- 스크립트에서는 스크립트 아래에 있는 DOM요소에 접근할 수 없다 
	  DOM요소에 이벤트 핸들러를 추가하는 등의 사용이 불가능하다 
	- 페이지 위쪽에 용량이 큰 스크립트가 있는 경우 스크립트가 페이지를 막아버린다 
	  페이지에 접속하는 사용자들은 스크립트를 다운받고 실행할 때 스크립트 아래쪽에 있는 페이지를 볼 수 없다 

1) defer
	defer 속성이 있는 스크립트를 백그라운드에서 다운로드 한다 
	지연 스크립트를 다운로드 하는 도중에도 HTML 파싱이 멈추지 않고 defer 스크립트 실행은 페이지 구성을 끝낼때까지 지연된다
	- 지연 스크립트는 페이지 생성을 절대 막지 않는다 
	- 지연 스크립트는 DOM에 준비된 후에 실행되긴 하지만 DOMConnectLoaded 이벤트 발생전에 실행된다 
	※ defer 속성은 외부 스크립트에만 유효하다 
	<script defer src="스크립트파일경로"></script>
	src 속성이 없으면 무시된다 

2) async(비동기 스크립트)
	페이지와 완전히 독립적으로 동작한다 

	- 백그라운드에서 다운로드한다 
	  html 페이지는 async 스크립트 다운이 완료되기를 기다리지 않고 페이지 내 콘텐츠를 처리하고 출력한다 
	(async 스크립트 실행중에는 HTML 파싱이 멈춘다) 
	- DOMConnectLoaded 이벤트와 async 스크립트는 서로를 기다리지 않는다 
	페이지 구성이 끝난 후에 async 스크립트 다운로딩이 끝난 경우 DOMContent
	DOMContentLoaded는 async 스크립트 실행 전에 발생할 수 있다 

3) 왜 defer와 async가 필요한가?
	브라우저가 <script>태그를 만나면 스크립트를 먼저 다운받고 실행도 먼저하게 됨
	이 때 HTML 파싱은 중단됨 -> 사용자 경험 저하(페이지가 늦게 보여짐) 성능저하
	HTML 렌더링을 막지 않도록 도와주는 속성이 defer와, async이고 반드시 사용해야한다 

4) defer와 async의 특징 
- defer
	html 파싱과 동시에 백그라운드에서 다운로드 
	HTML 파싱 완료 후, DOMContentLoaded 직전에 실행
	문서에 선언된 순서대로 실행 순서 보장됨 
	HTML 파싱은 절대 멈추지 않음 
	사용 : DOM 요소에 이벤트 핸들러를 추가하거나 여러개의 스크립트를 순서대로 실행해야 할 때

- async 
	HTML 파싱과 동시에 백그라운드에서 다운로드 
	다운로드 완료 즉시 실행(HTML 파싱이 멈춤) 
	먼저 다운된 게 먼저 실행되기 때문에 실행 순서는 보장되지 않음 
	HTML 파싱은 실행 순간만 멈춤 
	사용 : 스크립트가 페이지 구성과 무관할 때(광고, 통계 등) 
	
+) 기본 스크립트 
	HTML 파싱이 진행 -> 멈췄다가 스크립트 다운로드 스크립트 실행 -> HTML 파싱 재진행

  defer
	HTML 파싱이 진행 중 -> 스크립트를 다운로드 -> 스크립트 모두 DOM생성 후 실행 

  async
	HTML 파싱이 진행 중 -> 스크립트를 다운로드 -> 먼저 다운로드 된 즉시 실행(HTML 파싱 잠시멈춤) -> HTML 파싱 



* 오늘 피드백 받고 어제 과제 다시 제출하는 사람들 
폴더명 : task_백정이_재제출
	압축해서 제출 

오늘 진행하는 toDoList
폴더명 : todo_백정이
	압축해서 제출
https://polydactyl-raver-b64.notion.site/1717c072b11480fd87a5c15ff087dc68

--------------------------------------------------------------------------------------------컬렉션 프레임워크 -> 쓰레드

1. 컬렉션 프레임워크 
1) List, Set, Map 인터페이스 
	인터페이스 멤버 : 상수, 추상메소드, + 디폴트 메소드, 스태틱 메소드, private 메소드 
	List : 순서 보장, 중복값 허용o 
		추가, 수정, 삭제 가능 
		- ArrayList() 
	Set : 순서 보장x, 중복값 허용x
		추가, 삭제 가능(직접적인 수정은 불가능-인덱스가 없기 때문에, 요소 삭제후 새로운 값 추가하는 방식)
		- HashSet()
	Map : key-value 한쌍으로 관리
		key 중복 허용 x / value 중복값 허용 o 
		- HashMap()

2) Iterator : 반복자 
	컬렉션에 저장된 데이터를 컬렉션 종류와 상관없이 동일한 방식으로 가져오기 위한 인터페이스 
	hasNext() : 가져올 객체가 있으면 true, 없으면 false 반환하는 메소드 
	next() : 다음 값을 가져오는 메소드 
	iterator() : 컬렉션 객체를 Iterator 타입으로 변환할 때 

3) Entry 
	Map 인터페이스에서 정의된 중첩 인터페이스 
	Map에서 키와 값의 쌍을 표현할 수 있다 
	Map.Entry 각 키-값 쌍을 나타내고 맵의 항목들을 쉽게 순회하고 조작할 수 있도록 도와준다 
	Map.Entry는 주로 entrySet() 메소드를 통해 사용된다 
	entrySet() : 맵의 Entry 객체로 구성된 Set을 반환하는 메소드 
		키와 값의 쌍을 순회하고 조작할 수 있다 
	
2. 쓰레드(Thread) 
0) 쓰레드 알기 전 사전 지식 
	프로그램(소프트웨어)
		특정 작업을 수행하는 명령어(소스코드)들의 모음
		메모리를 할당받지 않은 상태 -> 꺼져있다 	
	
	프로세스 
		실행중인 프로그램(ctrl + shift + esc) 
		프로세스는 프로그램을 실행시키기 위한 메모리 등의 자원과 쓰레드로 구성된다 
		즉, 하나의 프로세스는 하나 이상의 쓰레드를 가지고 있다 

+) 컴퓨터 구성하는 3계층
	S/W	어플리케이션 
		시스템소프트웨어(Operating System)
	H/W
	

	시스템 자원 : 프로그램을 실행시키기 위해 필요한 것을 운영체제(OS)를 통해 제공받아야한다
			제공받는 것을 시스템 자원이라고 한다 
			파일, signal, 기타 소프트웨어 등 

	하드웨어 자원 : cpu, 주기억장치, 보조기억장치, 입출력장치 등 

1) 쓰레드 
	하나의 프로세스 내에서 작업을 처리하는 흐름의 단위 

- 싱글쓰레드
	하나의 쓰레드가 작업을 마치면 프로그램이 종료한다 
	쓰레드를 하나만 가지고 있기 때문에 작업을 순차적으로 처리하므로 상대적으로 비효율적이다 
	쓰레드는 자원을 사용하는데 싱글쓰레드는 혼자서 자원을 사용하므로 동기화를 걱정할 필요가 없다 
	따라서 안정성이 높고 설계가 쉽다 

- 멀티쓰레드 
	메인쓰레드가 작업을 마치더라도 다른 쓰레드의 작업이 모두 끝나야 프로그램이 종료된다 
	하나의 프로세스에서 여러 작업을 동시에 처리하는 것처럼 느껴지지만 사실은 각각의 쓰레드를 매우 빠른 속도로 	
	번갈아가면서 실행시켜서 조금씩 처리한다 
	쓰레드 간 공유하는 자원이 있다면 충돌 문제가 발생할 수 있으며 이러한 문제를 동기화(Synchronized)를 통해 해결한다 
	안정성이 떨어지고 설계가 어렵다  
	
2. 멀티쓰레드 
1) 멀티쓰레드 구현방법
	Thread 클래스 상속
	Runnable 인터페이스 구현 
	
	-> run() 메소드에 쓰레드가 처리할 작업을 재정의한다(오버라이딩)]
	-> start() 메소드로 쓰레드를 실행시킨다 

+) Thread.currentThread().getName()
	현재 실행중인 쓰레드의 이름을 반환하는 기능 
	어떤 쓰레드가 작업을 수행중인지 확인할 수 있다 

Thread.currentThread()
	Thread 객체의 정적메소드, 호출 되는 시점의 현재 쓰레드를 참조 
	현재 실행중인 쓰레드를 반환한다 

getName()
	Thread 객체의 인스턴스 메소드, 해당 쓰레드의 이름을 반환

쓰레드이름
	디버깅할 때 어떤 쓰레드가 작업을 하는지 조사할 목적으로 주로 사용한다 
	현재 코드를 어떤 쓰레드가 실행하는지 확인하려면 currentThread() 정적 메소드로 쓰레드 객체의 참조를 얻은 다음 
	getName() 메소드로 이름을 출력하면 된다 

	메인 쓰레드 : main 
	작업 쓰레드 : Thread-n의 이름을 가진다 
		작업 쓰레드의 이름을 다른 이름을 설정하고 싶다면 Thread클래스의 setName()메소드를 사용하면 된다
		thread.setName("쓰레드 이름"); 
	
2. 쓰레드(Thread)
0) 쓰레드 알기 전 사전 지식
   프로그램(소프트웨어)
      특정 작업을 수행하는 명령어(소스코드)들의 모음
      메모리를 할당받지 않은 상태 -> 꺼져있다

   프로세스
      실행중인 프로그램(ctrl + shift+esc)
      프로세스는 프로그램을 실행시키기 위한 메모리 등의 자원과 쓰레드로 구성된다
      즉, 하나의 프로세스는 하나 이상의 쓰레드를 가지고 있다

+) 컴퓨터 구성하는 3계층
   S/W   어플리케이션
      시스템 소프트웨어(Operating System)
   H/W
      
   시스템 자원 : 프로그램을 실행시키기 위해 필요한 것을 운영체제(OS)를 통해 제공받아야한다
         제공받는 것을 시스템 자원이라고 한다
         파일, signal, 기타 소프트웨어 등

   하드웨어 자원 : cpu, 주기억장치, 보조기억장치, 입출력장치 등

1) 쓰레드
   하나의 프로세스 내에서 작업을 처리하는 흐름의 단위

- 싱글쓰레드
   하나의 쓰레드가 작업을 마치면 프로그램이 종료한다
   쓰레드를 하나만 가지고 있기 때문에 작업을 순차적으로 처리하므로 상대적으로 비효율적이다
   쓰레드는 자원을 사용하는데 싱글쓰레드는 혼자서 자원을 사용하므로 동기화를 걱정할 필요가 없다
   따라서 안정성이 높고 설계가 쉽다

- 멀티쓰레드
   메인쓰레드가 작업을 마치더라도 다른 쓰레드의 작업이 모두 끝나야 프로그램이 종료된다
   하나의 프로세스에서 여러 작업을 동시에 처리하는 것처럼 느껴지지만 사실은 각각의 쓰레드를 매우 빠른 속도로
   번갈아가면서 실행시켜서 조금씩 처리한다
   쓰레드 간 공유하는 자원이 있다면 충돌 문제가 발생할 수 있으며 이러한 문제를 동기화(Synchronized)를 통해 해결한다
   안정성이 떨어지고 설계가 어렵다

3. 멀티쓰레드
1) 멀티쓰레드 구현방법
   Thread 클래스 상속
   Runnable 인터페이스 구현

   -> run() 메소드에 쓰레드가 처리할 작업을 재정의한다(오버라이딩)
   -> start() 메소드로 쓰레드를 실행시킨다

+) Thread.currentThread().getName()
   현재 실행중인 쓰레드의 이름을 반환하는 기능
   어떤 쓰레드가 작업을 수행중인지 확인할 수 있다

Thread.currentThread()
   Thread 객체의 정적메소드, 호출 되는 시점의 현재 쓰레드를 참조
   현재 실행중인 쓰레드를 반환한다

getName()
   Thread 객체의 인스턴스 메소드, 해당 쓰레드의 이름을 반환

쓰레드이름
   디버깅할 때 어떤 쓰레드가 작업을 하는지 조사할 목적으로 주로 사용된다
   현재 코드를 어떤 쓰레드가 실행하는지 확인하려면 currentThread() 정적 메소드로 쓰레드 객체의 참조를 얻은 다음
   getName()메소드로 이름을 출력하면 된다

   메인 쓰레드 : main
   작업 쓰레드 : Thread-n의 이름을 가진다
      작업 쓰레드의 이름을 다른 이름으로 설정하고 싶다면 Thread클래스의 setName()메소드를 사용하면 된다
      thread.setName("쓰레드 이름");

2) 멀티쓰레드 관련 메소드
(1) run()
   쓰레드가 호출하는 메소드

(2) start()
   쓰레드를 실행시키며, run()메소드를 호출한다

(3) sleep(long millis)
   매개변수로 전달한 시간동안 쓰레드를 멈춘다

(4) join() join(long millis)
   현재 쓰레드의 작업을 멈추고 join을 사용한 쓰레드를 기다린다
   매개변수에 값을 전달하지 않으면 현재 쓰레드가 join을 사용한 쓰레드의 작업이 끝날때까지 기다린다
   매개변수에 값을 전달하면 해당 시간동안 기다렸다가 현재 쓰레드를 다시 실행한다
   보통 먼저 실행시킬 쓰레드에 사용한다
(5) wait()
   동기화된 영역에서만 사용가능
   쓰레드의 lock을 회수하여 다른 쓰레드에게 제어권을 넘겨주고 대기한다(대기중에는 lock을 얻을 수 없다)

(6) notify()
   동기화된 영역에서만 사용가능
   대기 중인 쓰레드 중 하나를 깨운다
   실행 가능한 상태로 바뀌는 것이지 lock을 넘겨주는 것이 아니다

3) 쓰레드 동작과정
   Thread 클래스 상속 또는 Runnable 인터페이스를 통해 run()메소드 구현
   쓰레드 객체 생성
   start() 메소드 호출
   쓰레드 실행
   쓰레드 종료

4) 쓰레드 상태
   쓰레드는 생성된 후부터 종료될 때까지 여러 상태를 가질 수 있다
   
   NEW      쓰레드가 생성되고 아직 START()가 호출되지 않은 상태
   RUNNABLE   실행중 또는 실행가능한 상태
   BLOCKED      동기화 블록에 의해서 일시정지된 상태(LOCK이 풀릴 때까지 기다리는 상태)
   WAITING,    쓰레드의 작업이 종료되지 않았지만 실행가능하지 않음(UNRUNNABEL) 일시 정지 상태,
   TIMED_WAITING    일시정지 시간이 지정된 경우를 의미함
   TERMINATED   쓰레드의 작업이 종료된 상태

   객체생성 -> start() 호출 -> 실행 -> 실행 대기 -> 실행 -> 실행완료
   NEW  -> RUNNABLE   -> RUNNING -> WIATING / BOLCKED / TIMED_WAITING -> RUNNING -> TERMINATED

   쓰레드에서 처리할 로직을 run()메소드에서 구현하고 Thread 클래스의 start()메소드를 이용해 실행
   -> 실행 대기 상태로 들어감(JVM의 스케줄링에 의해 실행할 수 있는 상태)
   -> 자바 프로그램은 JVM에 의해 실행되는 쓰레드가 결정되며 이것을 스케줄링이라고 한다

5) 동기화(Synchronization) 
	A쓰레드와 B쓰레드가 작업을 진행할 때 A가 사용중인 자원을 B가 사용하여 변경한다면 A의 작업의도와 다르게 결과가 
	나타날 수 있다. 이러한 것을 방지하기 위해 하나의 자원을 여러 쓰레드가 동시에 접근하지 못하게 막는 것을 
	동기화라고한다 
	
- 동기화 영역 만들기 
	synchronized(객체명) {...} : 동기화 블록 
		일부 소스코드만 동기화를 걸어준다 
		쓰레드는 지정된 객체의 lock을 얻어내며 해당 객체의 lock을 가진 쓰레드만 동기화 블록에 접근이 가능하다 
	synchronized 리턴타입 메소드명(){...} : 동기화 메소드 
		해당 메소드 전체에 동기화를 걸어준다 

6) Lock 
	쓰레드가 공유되는 자원을 사용할 때 생기는 문제를 동기화로 해결한다 
	이 때 하나의 자원에 하나의 쓰레드만 접근하기 위해 사용되는 개념이 lock이다 
	자바의 모든 객체는 하나의 lock을 가지고 있다 
	동기화된 영역을 쓰레드가 사용하기 위해서는 lock을 획득해야만 하며, 
	동기화 영역을 벗어나면 

+) 교착상태(DeadLock) 
	멀티쓰레드 프로그램이나 멀티쓰레드 환경에서 발생하는 문제 
	여러 쓰레드가 서로 자원을 점유한 상태에서 다른 쓰레드가 점유하고 있는 자원을 기다리며 
	무한 대기 상태에 빠지는 비정상적인 상황을 의미함 

- 교착상태 해결 방법
	- 전체 쓰레드 깨우기 
		모든 쓰레드를 깨워서 무한 대기를 중단시킨다 
	- 특정 쓰레드 종료 
		특정 쓰레들를 강제로 종료하여 자원 점유를 해제시킨다 

- 교착상태 해결 전략(시험빈출)
	예방	교착상태가 발생하지 않도록 4가지 조건 중 최소 하나를 제거 
	회피 	교착상태가 발생할 수 있는 자원요청을 사전에 파악하여 허용여부결정
		-> 대표 알고리즘 : 은행가 알고리즘(Banker's Algorithm)
	탐지 	교착상태 발생을 허용하고 발생시 탐지 후 처리
	회복 	교착상태 탐지 후 특정 프로세스 종료 또는 자원회수로 해결 

- 교착상태가 발생하는 4가지 조건 
	- 상호배제 : 자원이 한번에 하나의 쓰레드만 사용할 수 있다 
	- 점유대기 : 한 쓰레드가 자원을 점유한 상태에서 추가로 다른 자원을 요청하며 대기한다 
	- 비선점 : 쓰레드가 점유한 자원을 빼앗을 수 없다 
	- 순환대기 : 두 개 이상의 쓰레드가 자원을 순환적으로 대기한다 

------------------------------------------------------------------------------------

프로젝트 진행 방향 
	기획(주제외 일치되는 레퍼런스 사이트 찾기 3개 선정) => 최종 1개 선정 + 화면(피그마 -> 화면그리기)
	어떤 서비스를 강점으로 할 지(주된 서비스 2개, 보조 서비스 3개) 

	화면 그리기(피그마)
	퍼블리싱(html, css, js)	프론트
	DB(모델링, 정규화, ERD)	백엔드
	백단 작업(JSP)		백엔드













































