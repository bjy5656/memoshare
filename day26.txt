---------------------------------------------------------------------------
복습(쿼리문) -> 소프트웨어 디자인설계 패턴 -> JDBC -> 연습 쿼리 -> 팀 과제

1. 소프트웨어 디자인 설계 패턴
1) 디자인 패턴의 3가지 분류(GoF : Gang of Four)
   생성(Creational)   객체 생성 방식 추상화   Singleton, Factory Method, Abstract Factory,
                  Builder, Prototype
   구조(Structural)   클래스/객체 조합 방식 정의   Adapter, Bridge, Composite, Decorator, Facade,
                  Flyweight, Proxy
   행위(Behavioral)   객체 간 책임 분산/통신   Observer, Stratege, Command, Template Method,
                  Iterator, State, Visitor, Mediator

- 생성 : 객체 생성에 관련된 패턴으로 객체 생성방식을 유연하고 재사용가능하게 만드는 방법을 제공
Singleton(싱글톤 패턴)
   전역변수를 사용하지 않고 객체를 하나만 생성하도록하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴
Builer(빌더 패턴)
   객체 생성과정과 표현과정을 분리하여 동일한 생성과정에서 다양한 표현을 생성가능
   복잡한 인스턴스를 조립하여 만드는 구조로, 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴
Abstract Factory(추상팩토리패턴)
   구체적인 클래스를 지정하지 않고 독립적인 객체들을 생성하기 위한 인터페이스를 제공
   구체적인 구현은 Concreate Product 클래스에서 이루어지는 특징을 갖는 디자인 패턴
Factory Method(팩토리 메소드 패턴)
   상위클래스에서 객체를 생성하는 인터페이스를 정의하고 하위클래스에서 인스턴스를 생성하도록 하는 방식, 
   가상생성자 패턴이라고도 불림
   객체 생성 처리를 서브클래스로 분리하여 처리하도록 캡슐화하는 패턴
Prototye(프로토 타입 패턴)
   생성할 객체의 종류를 명시하는데 원형을 먼저 만들어놓고 복사한 후 필요한 부분만 수정하여 사용하는 패턴
   생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 
   갖추어야할 기본형태가 있을 때 사용되는 디자인 패턴

- 구조 패턴 (Structural Patterns) : 클래스나 객체(구조)를 조합해 더 큰 구조를 만드는 방법 제공
Adapter (적응자 패턴)
   호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해줌
   기존 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴
   상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두 가지 형태로 사용되는 디자인 패턴
Bridge (브릿지 패턴)
   구현부와 추상층을 분리하여 각자 독립적으로 변형할 수 있도록 함
   기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 
   실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴
Composite (컴포지트 패턴)
   객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현함
   객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴
   사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 디자인 패턴
Decorator (데코레이터 패턴)
   주어진 상황 및 용도에 따라 객체에 책임을 덧붙임
   기능 확장이 필요할 때 서브클래스 대신 사용할 수 있는 대안
   기존에 구현되어 있는 클래스에 그 때 그 때 필요한 기능을 추가해 나가는 설계 패턴
   기능 확장이 필요할 때 객체간의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 상속의 대안으로 
   사용하는 디자인 패턴
Facade (퍼사드 패턴)
   서브시스템의 인터페이스 집합에 대해 통합된 하나의 인터페이스를 제공함
   복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간, 또는 여타 시스템과의 결합도를 낮추어 
   시스템 구조에 대한 파악을 쉽게 하는 패턴
   오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순한 인터페이스를 제공하여 접근성을 높일 수 있는 
   디자인 패턴
Flyweight (플라이웨이트 패턴)
   다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스화여 공유함으로써 메모리를 절약하고
   클래스의 경량화를 목적으로 하는 패턴
Proxy (프록시 패턴)
   다른 객체로의 접근을 통제하기 위해 그 객체의 매니저 또는 자리 채움자를 제공함
   실체 객체에 대한 대리 객체로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며
   이 점을 이용해 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며
   실체 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 패턴

- 행위 패턴 (Behavioral Patterns) : 객체나 클래스 간의 책임 분배와 상호작용 방법을 정의
Chain of Responsibility (책임 연쇄 패턴)
   요청을 처리할 수 있는 기회를 여러 객체에 부여해, 요청을 보낸 객체와 이를 처리하는 객체 간의 결합을 피함
   정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 시, 기능 처리의 연결 변경이 불가능한데 
   이를 동적으로 연결되어 있는 경우에 따라서 다르게 처리될 수 있도록 연결한 패턴
Command (커맨드 패턴)   
   요청을 객체로 캡슐화해 서로 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 연산 취소를 지원함
   실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴으로
   하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브클래스가 선택되어 
   실행되는 특징을 갖는 디자인 패턴
Mediator (미디에이터 패턴)   
   한 집합에 속하는 객체들의 상호작용을 캡슐화하는 객체를 정의
   객체지향 설계에서 객체의 수가 너무 많아지면 서로 통신하느라 복잡해져 객체지향에서 가장 중요한 느슨한 결합의
   특성을 해칠 수 있음. 이를 해결하는 한 가지 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 
   중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 
   객체지향의 목표를 달성하게 해주는 디자인 패턴
Memento (메멘토 패턴)
   클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴
   undo 기능을 개발할 때 사용하는 패턴
Observer Pattern (옵저버 패턴)
   한 객체의 상태 변화 시 그 객체에 의존하는 다른 객체들에 자동으로 통보하고 갱신하는 패턴입
   한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방법으로
   일대다 의존성(one-to-many)을 가지는 디자인 패턴과 서로 상호작용을 하는 객체 사이에서는 가능하면 
   느슨하게 결합하는 디자인패턴
State (상태 패턴)   
   객체의 내부 상태가 변경될 때 행동을 변경하도록 합니다. 객체는 자신의 클래스가 변경되는 것처럼 보임
   객체 상태를 캡슐화하여 클래스화 함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록
   행위 내용을 변경하여, 변경 시 원시 코드의 수정을 최소화할 수 있고, 유지 보수의 편의성도 갖는 디자인 패턴
Strategy (전략 패턴)
   동일 계열의 알고리즘들을 정의하고 각각 캡슐화하여 이들을 상호 교환 가능하도록 만듦
   알고리즘 변경을 사용자로부터 독립적으로 할 수 있음
   알고리즘 군을 정의하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화하고 난 뒤, 
   필요할 때 서로 교환해서 사용할 수 있게 하는 패턴으로, 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 
   바꿀 수 있게 해주는 패턴
Template Method (템플릿 메서드 패턴)
   연산의 알고리즘 뼈대를 정의하고, 나머지는 서브클래스에서 수행하게 함
   어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 
   특정 단계에서 수행하는 내역을 바꾸는 패턴으로 일반적으로 상위 클래스(추상 클래스)에는 추상 메서드를 통해
   기능의 골격을 제공하고, 하위 클래스(구체 클래스)의 메서드에는 세부 처리를 구체화하는 방식으로 사용하며 
   코드 양을 줄이고 유지보수를 용이하게 만드는 특징을 갖는 패턴
Visitor (비지터 패턴)
   객체 구조를 이루는 원소에 대해 수행할 연산을 정의함
   각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 
   각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴으로, 객체의 구조는 변경하지 않으면서 기능만
   따로 추가하거나 확장할 때 사용하는 디자인 패턴
Interpreter (인터프리터 패턴)
   주어진 언어의 문법을 표현하는 방법을 정의하고, 해당 언어로 된 문장을 해석하는 해석기를 사용하는 패턴
   언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 
   여러 형태의 언어 구문을 해석할 수 있게 만드는 패턴
Iterator(이터레이터 패턴, 반복자 패턴)
   컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있는 방법을 제공
   하는 디자인 패턴. 집합 객체의 요소들에 대해 순서대로 접근하는 방법을 제공함
   서로 다른 집합 객체 구조에 대해 동일한 방법으로 순회할 수 있음

2. 소프트웨어 아키텍처 디자인 패턴 
	소프트웨어 시스템을 효율적으로 견고하게 설계하기 위한 구조적인 틀 
	소프트웨어를 구성하는 고수준 구조(High-level Structure) 
	모듈 간 역할과 관계, 데이터 흐름을 정의 
	확장성, 재사용성, 유지보수성 향상 

- Layered Pattern(계층형 구조) 
	가장 전통적인 구조 
	장점 : 분리 쉬움, 테스트 편함 
	단점 : 계층 간 호출이 많으면 성능 저하 가능 

- Client-server Pattern 
	서버가 서비스 제공, 클라이언트는 요청 
	장점 : 구조 단순, 네트워크 기반 설계 용이 
	단점 : 서버 부하 발생 가능성, 연결 장애 시 취약 

- Event-Drives Pattern(이벤트 기반) 
	이벤트가 발생하면 관련 모듈이 반응함 
	주로 비동기 구조 
	장점 : 유연성 높음, 느슨한 결합 
	단점 : 흐름 추적 어려움, 디버깅 어려움 

- Microservices Pattern 
	기능별로 독립된 작은 서비스들로 구성 
	각 서비스가 자체 DB, 로직, API을 가짐 
	서비스 간 통신은 REST, 메시지 큐 등으로 연결 
	장점 : 독립배포, 확장 용이, 장애 격리 
	단점 : 시스템 복잡도 증가, 통합 테스트 어려움 

- MVC(Model-View-Controller) 
	사용자 인터페이스와 로직을 분리 
	장점 : 역할 분리, 유지보수 편함 
	단점 : 단순한 어플리케이션에서는 오히려 과함 

- MVM(Model-View-ViewModel) 
	viewModel이 View와 Model을 바인딩 
	viewModel은 View와 데이터를 자동으로 동기화 
	장점 : 바인딩 자동화, UI 코드 깔끔 
	단점 : 초반 구조 설계 복잡 

- Pipe and Filter Pattern 
	데이터를 여러 처리 단계(Pipe)로 연결 
	각 단계(Filter)는 데이터를 가공 
	장점 : 모듈 재사용 쉬움 
	단점 : 실시간 처리엔 부적합

3. MVC 
	M(Model) 	테이블에서 조회된 결과값을 담기 위한 변수들이 선언된 클래스
			클래스명 뒤에 DTO, VO 라는 문자열을 붙여준다 
			VO(Value Object) : 테이블을 보고 그대로 만든 객체 
			DTO(Data Transfer Object) : 화면에 결과를 한번에 묶어서 전달할 객체 

	V(View)		: 사용자에게 보여질 화면을 구성하는 부분
			Controller에 선언된 CRUD 메소드를 사용할 부분 

	C(Controller)	: jsp에서 더 자세히 알아보자!
			DAO(Data Access Object) : 테이블에 접근할 수 있는 메소드들이 선언된 클래스 
			접근 후 결과 값이 있을 경우 Model 객체에 담은 후 처리 

4. JDBC 
	Java Database Connectivity(자바 데이터베이스 연결) 
	자바 프로그램과 데이터베이스를 연결시켜주는 API 
	
JDBC Driver 	=> jar로 다운받아서(Build Path 추가 후 사용) 
		클래스로, 객체로 다룬다 
	해당 클래스에서 제공하는 기능들(메소드)을 활용하여 DB와 소통하는 API 



[팀 과제]
도서관 프로젝트 진행한 것 
패키지 다시 나눈다	=> 1차 검토 
클래스 수정	=> 2차 검토 

DB 계정 변경 후 진행(새로 만든다) team01, team02, team03






















































