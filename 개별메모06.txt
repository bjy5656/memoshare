.nextDouble()
- printf, println 으로 출력할 때 소수점 몇 자리까지 출력되는지 확인 
- printf : 50.55 입력 => 50.550000, 소수점 아래 6자리까지 출력 
- println : 50.55 입력 => 50.55, 입력한 그대로 출력

ctrl + shift + / => 여러 줄 주석 

print문 소괄호 안에서 연산자 우선순위에 유의

비트연산자
- 비트로 바꾸고 산술 연산하는 과정이 생략되어 속도가 향상된다. 
- 암호화에 사용될 수 있다.
- 10 -> 00001010

음수 표현 및 보수, 비트연산 NOT(~)
- 컴퓨터는 0과 1로 이루어진 값만 계산할 수 있으며 (-) 부호가 있는 수를 계산한다는 개념을 갖고있지 않다.(뺄셈을 하지 못한다.) 
- 맨 앞의 비트를 기준으로 0을 양수로, 1을 음수로 구분한다. 
- 단순히 맨 앞의 비트를 구분하는 것으로는 뺄셈 연산을 할 수 없다. 음수를 표현하는 부호비트 1이 그대로 남게 되며 값을 나타내는 비트도 합연산된다.
 	=> 00001010 : 10 + (10001010 : -10) => 10010100 : 128 + 20
- 따라서 음수는 양수의 2의 보수로 표현되며, 0이 1로, 1이 0으로 바뀌고 1이 더해진다.
- 보수 : 더했을 때 특정 수가 되는 수 
- n진수 기준 n-1의 보수 : 각 자리수를 더했을 때 각각 n-1이 되는 수 
			=> 10진수 157의 9의 보수 => 842(157+842=999)
			=> 2진수 1101의 1의 보수 => 0010(1101+0010=1111)
- n진수 기준 n의 보수 : 더했을 때 맨 앞자리에서 올림한 수가 되는 수 
			=> 10진수 157의 10의 보수 => 843(157+843=1000)
			=> 2진수 1101의 2의 보수 => 0011(1101+0011=10000)
- n진수 기준 n의 보수는 n-1의 보수 + 1이다. 
- 어떤 수의 n진수 기준 n의 보수를 음수로 표현한다. 
- 보수를 이용한 뺄셈 
		10진수	=> 356 - 245 
			=> 356 + (1000-245)
			=> 356 + 755
			=> 1111 => 맨 앞자리 1은 버림 
		2진수 	=>  1010 - 0011
			=> 1010 + (10000 - 0011) 
			=> 1010 + 1101
			=> 10111 => 맨 앞자리 1은 버림 
- 2진수에서 1의 보수는 단순히 각비트의 숫자가 뒤바뀌게 되고 2의 보수는 그 값에서 1을 더하면 된다. 
- 비트연산 NOT(~) : 각 비트의 숫자를 바꾼다. 
- NOT(~)연산된 수가 음수일 때 그 수를 10진수로 표현하면 해당 수를 2의 보수로 갖는 수를 10진수로 표현하고 (-)부호를 붙이면 된다.
			=> 양수 n을 ~ 연산했을 때 음수값 -x
			=> ~n = x의 2의 보수 
			=> ~n = ~x + 1
			=> ~x = ~n - 1
			=> ~x = ~(n + 1)
			=> x = n + 1
	
			=> ~9 => ~1001 => 0110
			=> 10의 2의 보수 => ~1010 + 1 => 0110

int를 이진수로 표현 
- Integer.toBinaryString(num)

switch, case 문 
- switch 옆 소괄호 안의 값에 해당하는 case를 만났을 때 코드를 실행
- 해당 case를 만나기 전까지는 코드를 실행하지 않는다. 
- 해당 case이후 코드를 break;를 만나기 전까지 계속 실행한다.
- break;를 만나면 switch문을 탈출한다. 
